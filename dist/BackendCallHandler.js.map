{"version":3,"sources":["BackendCallHandler.ts"],"names":["BackendCallHandler","BackendCallHandler.constructor","BackendCallHandler.singleton","BackendCallHandler.stateless","BackendCallHandler.statefull","BackendCallHandler.getRegistry","BackendCallHandler.execute","BackendCallHandler.broadcastExecute","BackendCallHandler.sendResponseToOrigin","BackendCallHandler.sendErrorToOrigin","BackendCallHandler.useResponse","BackendCallHandler.receiveClientError","BackendCallHandler.getClientResponseWithId","BackendCallHandler.log"],"mappings":"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","file":"BackendCallHandler.js","sourcesContent":["/// <reference path=\"../typings/ws/ws.d.ts\" />\n/// <reference path=\"Registry.ts\" />\n/// <reference path=\"JsonRpc.ts\" />\n/// <reference path=\"EventBus.ts\" />\nimport ws = require('ws');\nimport reg = require('./Registry');\nimport jrpc = require('./JsonRpc');\nimport bus = require('./EventBus');\n\nexport var DEBUG:boolean = false;\n\nexport module api {\n    export interface IBackendCallHandler {\n        singleton(instanceName:string, classNames:any);\n        stateless(instanceName:string, classNames:any);\n        statefull(instanceName: string, classNames: any);\n        getRegistry(instanceName:string): reg.api.IRPCRegistry;\n\n        execute(client: WebSocket, instance: string, method: string, params: JSON, id: string);\n        broadcastExecute(server: ws.Server, client: WebSocket, instance: string, method: string, params: JSON, id: string);\n        sendResponseToOrigin(client: any, id: string, result: JSON);\n        sendErrorToOrigin(client: any, id: string, code: number, message: string);\n        useResponse(id: string, result: JSON);\n        receiveClientError(rpc: jrpc.RPC);\n    }\n}\n\nexport class BackendCallHandler implements api.IBackendCallHandler {\n\n    private _singleton: reg.ObjectRegistry;\n    private _stateless: reg.ClassRegistry;\n    private _names: { [name: string]: Object };\n    private _eventBus: bus.EventBus;\n    private _pendingRequest: { [id: string]: any };\n\n    constructor() {\n        this._names = {};\n        this._singleton = new reg.ObjectRegistry();\n        this._stateless = new reg.ClassRegistry();\n        this._pendingRequest = {};\n        this._eventBus = bus.EventBus.getSharedEventBus();\n    }\n\n    public singleton(instanceName: string, classNames: any) {\n        this._names[instanceName] = this._singleton;\n        this._singleton.register(instanceName, classNames);\n    }\n\n    public stateless(instanceName: string, classNames: any) {\n        this._names[instanceName] = this._stateless;\n        this._stateless.register(instanceName, classNames);\n    }\n\n    public statefull(instanceName: string, classNames: any) {\n        console.warn('Session objects not implemented yet !');\n    }\n\n    public getRegistry(instanceName: string): reg.api.IRPCRegistry {\n        if (this._names[instanceName] === this._singleton) {\n            return this._singleton;\n        }\n        else if (this._names[instanceName] === this._stateless) {\n            return this._stateless;\n        }\n        return null;\n    }\n\n    public execute(client:WebSocket, instance:string, method:string, params:JSON, id:string) {\n        if (this._names[instance]) {\n            var registry:reg.api.IRPCRegistry = null;\n            if (this._names[instance] === this._singleton) {\n                registry = this._singleton;\n            }\n            else if (this._names[instance] === this._stateless) {\n                registry = this._stateless;\n            }\n            try {\n                var result:JSON = registry.invoke(instance, method, params);\n                client.send(JSON.stringify(jrpc.RPC.Response(id, result)));\n            } catch (err) {\n                console.warn('RPC backend call \"' + instance + '.' + method + '\" fail.');\n                BackendCallHandler.log('<<BackendCallHandler ' + JSON.stringify(jrpc.RPC.Error('Error', jrpc.RPC.INTERNAL_ERROR,\n                        'RPC backend call \"' + instance + '.' + method + '\" fail.')));\n                client.send(JSON.stringify(jrpc.RPC.Error('Error:' + id, jrpc.RPC.INTERNAL_ERROR,\n                    'RPC backend call \"' + instance + '.' + method + '\" fail.')));\n            }\n        }\n        else {\n            console.warn('RPC backend instance named ' + instance + ' not  found.');\n            client.send(\n                JSON.stringify(\n                    jrpc.RPC.Error('Error:' + id, jrpc.RPC.METHOD_NOT_FOUND, 'RPC backend instance named ' + instance + ' not found.')\n                )\n            );\n        }\n    }\n\n    public broadcastExecute(server: ws.Server, client: WebSocket, instance: string, method: string, params: JSON, id: string) {\n        this._pendingRequest[id] = client;\n        var m: string = instance + '.' + method;\n        var newRpc = jrpc.RPC.Request(id, m, params);\n        server.clients.forEach((_client) => {\n            _client.send(JSON.stringify(newRpc));\n        });\n    }\n\n    public sendResponseToOrigin(client: any, id: string, result: JSON) {\n        if (id && client) {\n            var newRpc = jrpc.RPC.Response(id, result);\n            client.send(JSON.stringify(newRpc));\n        }\n    }\n\n    public sendErrorToOrigin(client: any, id: string, code: number, message: string) {\n        if (id && client) {\n            var newRpc = jrpc.RPC.Error(id, code, message);\n            client.send(JSON.stringify(newRpc));\n        }\n    }\n\n    public useResponse(id: string, result: JSON) {\n        this._eventBus.fire(id, result);\n    }\n\n    public receiveClientError(rpc: jrpc.RPC) {\n        BackendCallHandler.log('Get error : ' + JSON.stringify(rpc));\n    }\n\n    public getClientResponseWithId(id: string): any {\n        return this._pendingRequest[id];\n    }\n\n    public static log(...args:any[]) {\n        if (DEBUG) {\n            console.log(args);\n        }\n    }\n}"],"sourceRoot":"/source/"}